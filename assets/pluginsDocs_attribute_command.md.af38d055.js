import{_ as s,c as a,o as n,a as l}from"./app.a5da328c.js";const C=JSON.parse('{"title":"Command特性","description":"","frontmatter":{},"headers":[{"level":2,"title":"自定义回复前缀","slug":"自定义回复前缀","link":"#自定义回复前缀","children":[]},{"level":2,"title":"自定义命令","slug":"自定义命令","link":"#自定义命令","children":[]},{"level":2,"title":"特殊情况","slug":"特殊情况","link":"#特殊情况","children":[{"level":3,"title":"全监听","slug":"全监听","link":"#全监听","children":[]},{"level":3,"title":"正则监听","slug":"正则监听","link":"#正则监听","children":[]}]}],"relativePath":"pluginsDocs/attribute/command.md"}'),o={name:"pluginsDocs/attribute/command.md"},p=l(`<h1 id="command特性" tabindex="-1">Command特性 <a class="header-anchor" href="#command特性" aria-hidden="true">#</a></h1><p>Command提供了两个功能：</p><ul><li>自定义回复前缀</li><li>自定义消息触发体</li></ul><p>命令原型 <code>[Command(CommandAttribute.Prefix,para string[])]</code></p><h2 id="自定义回复前缀" tabindex="-1">自定义回复前缀 <a class="header-anchor" href="#自定义回复前缀" aria-hidden="true">#</a></h2><p>自定义消息的回复前缀，有三个可选项：</p><ul><li>None:表示插件不需要使用前缀</li><li>Single:表示插件需要使用前缀，且前缀由插件自己提供</li><li>Global:表示插件需要使用前缀，且前缀由框架提供（也就是用户提供）</li></ul><h2 id="自定义命令" tabindex="-1">自定义命令 <a class="header-anchor" href="#自定义命令" aria-hidden="true">#</a></h2><p>命令表示插件触发命令后Action所做的事情。</p><p>注意，若同一个命令头被注册，那么会按照框架用户定义的优先级执行。若优先级较低且优先级较高的插件拦截了消息请求，那么插件Action可能出现不会被触发的现象。</p><p>命令分为两个部分，一个是母命令头，一个是参数部分，例如：</p><p><code>Say [type]</code></p><p>那么当用户输入Say时会传入Action，且空格后的被解析成为参数。</p><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>由于语义的歧义性，Sorux仅支持<code>string</code>和<code>int</code>类型的解析，且不支持其他类型的解析。</p></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Sorux的参数类型解析是根据Action的参数类型进行解析转换的。当声明了Action的参数类型时，参数会被对应解析成相应的类型。</p></div><p>框架提供参数注入，有两种参数类型：</p><ul><li><code>[Para]</code>:以中括号包围的被称为必须参数，表示参数一定要存在</li><li><code>&lt;Para&gt;</code>:以尖括号包围的被称为可选参数，表示参数不存在</li></ul><p>在Command声明的参数应当与Action函数参数的顺序一致，且可选参数需要使用<code>?</code>做Nullable声明。此外，必须设计为必须参数在前，可选参数在后的结构，否则会引发歧义。</p><h2 id="特殊情况" tabindex="-1">特殊情况 <a class="header-anchor" href="#特殊情况" aria-hidden="true">#</a></h2><p>正常情况下，插件Action的参数注入应当是可选参数或必须参数。但是，在一一对应注入之外，框架也提供了一些特殊注入，适配于参数并非一一注入的情况。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在正常注入下，每个参数会一一匹配，若参数数目不匹配则会检查参数是否可选，若均不符合那么会视为消息发生了“匹配丢失”，这说明不会有任何一个Action被触发。</p></div><h3 id="全监听" tabindex="-1">全监听 <a class="header-anchor" href="#全监听" aria-hidden="true">#</a></h3><p>全监听指的是Action不需要向框架请求参数注入，而是以“事件”方式进行监听。简而言之，发送的任何消息都会进入Action。</p><p>我们需要这样去声明这样的一个Action:</p><div class="language-csharp"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">Event</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">EventType</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SoloMessage</span><span style="color:#89DDFF;">)]</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">Command</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CommandAttribute</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Prefix</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">None</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">[SF-ALL]</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)]</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PluginFucFlag</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Test</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">MessageContext</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">context</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">msg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">//此处进行一些逻辑处理</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>[SF-ALL]</code>与<code>CQ码</code>的概念类似，指的是以简短的字符串表示特殊含义的语句。 请不要写为<code>[SF:ALL]</code>这可能会造成将名称为SF的参数解析为ALL类型的参数注入歧义的现象。 其中，SF表示的是SoruxBotFramework，简称SF。</p></div><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>请保持Action的命令注册在逻辑上一致。若消息被注册为全监听，那么不应该有&quot;命令头&quot;，也不应该有触发的&quot;Prefix&quot;，若存在二者中任何一个，或二者均存在，那么会造成命令解析的歧义。</p></div><h3 id="正则监听" tabindex="-1">正则监听 <a class="header-anchor" href="#正则监听" aria-hidden="true">#</a></h3><p>正则监听指的是Action需要更为复杂的命令路由解析，以简化在Action内部判断的流程。 正则监听需要使用<code>SF-Regex</code>标注，如下述例子：</p><div class="language-csharp"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">Event</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">EventType</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">SoloMessage</span><span style="color:#89DDFF;">)]</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">[</span><span style="color:#FFCB6B;">Command</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CommandAttribute</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">Prefix</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">None</span><span style="color:#89DDFF;">,</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test [SF-Regex-正则表达式]</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">)]</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#C792EA;">public</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">PluginFucFlag</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Test</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">MessageContext</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">context</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">string</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">msg</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">	</span><span style="color:#676E95;font-style:italic;">//此处进行一些逻辑处理</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><p>其中，正则表达式这五个字应该被替换成对于的正则表达式。</p>`,31),e=[p];function t(c,r,i,F,D,d){return n(),a("div",null,e)}const A=s(o,[["render",t]]);export{C as __pageData,A as default};
